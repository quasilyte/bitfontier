package fontgen

import (
	"text/template"
)

type templateData struct {
	PkgName string

	Fonts        []*sizedBitmapFont
	RuneMappings []*runeMapping

	CompactRune bool

	OnMissing string
}

type runeMapping struct {
	SizeApprox int
	Slice      []runeAndIndex
}

type runeAndIndex struct {
	Rune  rune
	Index int
}

var fontfaceTemplate = template.Must(template.New("fontface").Parse(`// Code generated by fontget, DO NOT EDIT

package {{$.PkgName}}

import (
	"golang.org/x/image/font"
	_ "embed"
)

{{ if $.CompactRune }}
// runeAndIndex is a compact version for fonts with low max rune bound.
// Its size is 4 bytes instead of 8.
type runeAndIndex struct {
	r uint16
	i uint16
}
{{ else }}
type runeAndIndex struct {
	r rune // int32
	i uint32
}
{{ end }}

{{- range $.Fonts}}
// New{{.ShortSizeTag}} allocates a font of size={{.Size}}.
//
// Allocating several instances of the same-sized font is unadvised
// as they would not share the resources.
func New{{.ShortSizeTag}}() font.Face {
	data := uncompress(size{{.SizeTag}}data)
	img := newBitmapImage(data, {{.GlyphWidth}}, {{.GlyphHeight}})
	f := newBitmapFont({{.Index}}, img, {{.DotX}}, {{.DotY}})
	f.MinRune = {{.MinRune}}
	f.MaxRune = {{.MaxRune}}
	f.XHeight = {{.XHeight}}
	f.CapHeight = {{.CapHeight}}
	f.GlyphBitSize = {{.GlyphBitSize}}
	f.RuneMapping = size{{.SizeTag}}mapping[:]
	return f
}
{{end}}

var (
	{{- range $.Fonts}}
	//go:embed {{.BitmapFilename}}
	size{{.SizeTag}}data []byte 
	{{end}}
)

const (
	onMissing = "{{.OnMissing}}"
)

func getStubImageIndex(id int) uint {
	switch id {
	{{- range $.Fonts }}
	case {{.Index}}: // size={{.SizeTag}}
		return {{.StubDataIndex}}
	{{- end }}
	default:
		panic("unreachable")
	}
}

var (
	{{- range $.Fonts}}
	{{- $m := (index $.RuneMappings .Index)}}
	// len={{len $m.Slice}} sizeApprox={{$m.SizeApprox}}
	size{{.SizeTag}}mapping = [...]runeAndIndex{
		{{- range $m.Slice}}
			{r: {{.Rune}}, i: {{.Index}} }, // {{printf "%q" .Rune}}
		{{- end}}
	}
	{{end}}
)
`))
