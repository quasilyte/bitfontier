package fontgen

import (
	"text/template"
)

type templateData struct {
	PkgName string

	Fonts        []*sizedBitmapFont
	RuneMappings []*runeMapping

	OnMissing string
}

type runeMapping struct {
	SizeApprox int
	Slice      []runeAndIndex
}

type runeAndIndex struct {
	Rune  rune
	Index int
}

var fontfaceTemplate = template.Must(template.New("fontface").Parse(`// Code generated by fontget, DO NOT EDIT

package {{$.PkgName}}

import (
	"golang.org/x/image/font"
	_ "embed"
)

{{- range $.Fonts}}
// New{{.ShortSizeTag}} allocates a font of size={{.Size}}.
//
// Allocating several instances of the same-sized font is unadvised
// as they would not share the resources.
func New{{.ShortSizeTag}}() font.Face {
	data := uncompress(size{{.SizeTag}}data)
	img := newBitmapImage(data, {{.GlyphWidth}}, {{.GlyphHeight}})
	f := newBitmapFont(img, {{.DotX}}, {{.DotY}})
	f.MinRune = {{.MinRune}}
	f.MaxRune = {{.MaxRune}}
	f.GlyphBitSize = {{.GlyphBitSize}}
	f.RuneMapping = size{{.SizeTag}}mapping[:]
	return f
}
{{end}}

var (
	{{- range $.Fonts}}
	//go:embed {{.BitmapFilename}}
	size{{.SizeTag}}data []byte 
	{{end}}
)

var (
	{{- range $.Fonts}}
	{{- $m := (index $.RuneMappings .Index)}}
	// len={{len $m.Slice}} size_approx={{$m.SizeApprox}}
	size{{.SizeTag}}mapping = [...]runeAndIndex{
		{{- range $m.Slice}}
			{r: {{.Rune}}, i: {{.Index}} }, // {{printf "%q" .Rune}}
		{{- end}}
	}
	{{end}}
)

const (
	onMissing = "{{.OnMissing}}"
)
`))
